// input: f0,f1 two hom polys of same degree
// output: the values of t for which the hypersurface (1-t)*f0+t*f1 is singular
// assuming general fiber is smooth
function singularFibersOfPencil(f0,f1:KK:=ComplexField(20))
  P:=Parent(f0);
  R<t>:=PolynomialRing(Rationals(),Ngens(P)+1,"elim",1);
  inc:=hom<P->R|[R.i : i in [2..Ngens(R)]]>;
  F:=(1-t)*inc(f0)+t*inc(f1);
  I:=ideal<R|[Derivative(F,i): i in [2..Ngens(R)]]>;
  J:=ideal<R|[R.i : i in [2..Ngens(R)]]>;
  IJ:=Saturation(I,J);
  gb:=GroebnerBasis(IJ);
  polys:=[p : p in gb | IsUnivariate(p,t)];
  rts:=[KK|];
  for p in polys do
    _,h:=IsUnivariate(p);
    rts:=rts cat [r[1] : r in Roots(h,KK)];
  end for;
  return rts;
end function;


function squareDistance(lineSegment,pt)
  v:=lineSegment[1];
  w:=lineSegment[2];
  if v eq w then
    return (v-pt,v-pt);
  end if;
  t:=(w-v,pt-v)/(w-v,w-v);
  tt:=Maximum(0,Minimum(t,1));
  closestPoint:=v+tt*(w-v);
  return (closestPoint-pt,closestPoint-pt);
  //return v+tt*(w-v);
end function;

function weight(lineSegment,pts)
  wgt:=0;
  for pt in pts do
    dist:=squareDistance(lineSegment,pt);
    if dist eq 0 then
      return -1;
    end if;
    wgt+:=1/dist;
  end for;
  return wgt;
end function;

function randomPoints(V,num : center:=(V!0), ranges:=[2: i in [1..Dimension(V)]])
  Reals:=RealField(20);
  F:=Field(V);
  d:=Dimension(V);
  return [center + V![Reals|Random([-ranges[j],ranges[j]])*Random(10^20)/10^20 : j in [1..d]] : i in [1..num]];
end function;

function addSegment(path,newPoint,avoid)
  problem:=false;
  if path[#path] eq newPoint then 
    problem:=true;
  end if;
  newSegment:=[path[#path],newPoint];
  wt:=weight(newSegment,avoid);
  if wt eq -1 then 
    problem:=true;
  end if;
  return Append(path,newPoint),wt,problem;
end function;


// avoid is a sequence of points in a 2 dimensional real vector space
// maxsteps is the number of steps in the rectilinear path
// output is a rectilinear path from 0 to 1 avoiding the list of points as much as possible
// N and n control the evolutionary algorithm, N=sample size, n=survivors from each generation
function findPath(avoid:maxSteps:=5, n:=5,N:=100)
  V:=VectorSpace(RealField(20),2);
  p0:=V!0;
  p1:=V![1,0];
  avoid:=[a : a in avoid | not ((a eq p0) or (a eq p1))];

  if #avoid eq 0 then 
    return [p0,p1], 0;
  end if;

  bestPaths:=[[p0] : i in [1..n]];
  weights:=[Field(V)|0:i in [1..n]];

  centers:=[V![i/maxSteps,0] : i in [0..maxSteps]];
  rangex:=2/maxSteps;

  if maxSteps eq 1 then
    return [p0,p1], weight([p0,p1],avoid);
  end if;

  for step in [1..(maxSteps-1)] do
    for i in [1..n] do
      newPaths:=[];
      newWeights:=[];
      path:=bestPaths[i];
      rps:=randomPoints(V,N : center:=centers[step],ranges:=[rangex,1]);
      for p in rps do
        newpath,wt,problem:=addSegment(path,p,avoid);
        wt:=wt*(p-p1,p-p1)*maxSteps/(maxSteps-step);
        if problem then break; end if;
        if step eq maxSteps-1 then
         newpath,wt2,problem:=addSegment(newpath,p1,avoid);
         wt2:=wt2*(p-p1,p-p1)*maxSteps/(maxSteps-step);
         wt:=wt+wt2;
          if problem then break; end if;
        end if;
        Append(~newPaths,newpath);
        Append(~newWeights,weights[i]+wt);
      end for;
      ParallelSort(~newWeights,~newPaths);
      bestPaths[i]:=newPaths[1];
      weights[i]:=newWeights[1];
    end for;
  end for;

  // try also the straight path
  str:=[p0,p1];
  wt:=weight([p0,p1],avoid);
  if not wt eq -1 then
    Append(~weights,wt);
    Append(~bestPaths,str);
  end if;
  ParallelSort(~weights,~bestPaths);

  return bestPaths[1], weights[1];
end function;

function PathFinder2(allODEs)
print "\nPathFinder2 initiated.";
Reals:=RealField(20);
CC:=ComplexField(10);
V:=VectorSpace(Reals,2);
K<t>:=FunctionField(Rationals());
// Vieweing the univariate ring
// as a multivariate ring is necessary
//in order to use clear denominators function
RR<D>:=PolynomialRing(K,1);
multi:=hom<Parent(allODEs[1,1])->RR|RR.1>;
allODEs:=[[multi(ode) : ode in odes] : odes in allODEs];

time0 := Cputime();
allSings:=[];
paths:=[];
counter:=0;
printf "There are %o systems to navigate through.\n", #allODEs;
for odes in allODEs do
  counter+:=1;
  print "Working on system number", counter;
  sings:=[];
  for ode in odes do
    _,leadingTerm:=ClearDenominators(ode);
    // get all the roots except for 0 and 1
    sings:=sings cat [V|[Re(root[1]),Im(root[1])] : root in Roots(leadingTerm,CC) | Abs(root[1]) gt 10^(-10) and Abs(root[1]-1) gt 10^(-10)];
  end for;
  path:=findPath(sings);
  //path:=[CC| pt[1] + pt[2]*I : pt in path];
  Append(~paths,path);
  Append(~allSings,sings);
end for;

printf "It took %o seconds to find singularities of the ODEs and a rectilinear path through them.\n\n", Cputime()-time0;

return paths,allSings;

end function;

// cmlxPts is a list of points in the complex field
// output is a list of the corresponding points in a 2 dimensional real vector space
function complexToPlane(cmplxPts:precision:=20)
  reals:=RealField(precision);
  V:=VectorSpace(reals,2);
  return [V|[Re(pt),Im(pt)] : pt in cmplxPts]; 
end function;

function planeToComplex(planePts:precision:=20)
  CC<I>:=ComplexField(precision);
  AssignNames(~CC,["I"]);
  return [pt[1]+pt[2]*I : pt in planePts];
end function;

function PathFinder1(deformationPath)
  noOfFamilies:=#deformationPath-1;
  print "\nPathFinder1 initiated."; //If it succeeds it will give a pretty good path of integration. However, it is potentially very expensive. If this one gets stuck, try PathFinder2.\n\n";
  printf "There are %o systems to navigate through.\n", noOfFamilies;
  paths:=[];
  allSings:=[];
  time0 := Cputime();
  for i in [1..noOfFamilies] do
    print "Working on system number", i;
    sFibs:=singularFibersOfPencil(deformationPath[i],deformationPath[i+1]);
    sFibs2D:=complexToPlane(sFibs);
    path:=findPath(sFibs2D);
    Append(~paths,path);
    Append(~allSings,sFibs2D);
  end for;
  print "\nPathFinder1 terminated in", Cputime()-time0,"seconds.";

  return paths, allSings;
end function;
