//// Part I : Computing the Picard-Fuchs equations

////////////////////////////////
/// GriffithsDwork reduction ///
////////////////////////////////


// input: 
// L a nested list of polynomials
// f defines a smooth hypersurface
// depth is the nesting depth of L 
// output:
// GD reduction of polynomials of L wrt f
// in the same nesting structure of L
function GriffithsDwork(L,f : depth:=0)
  P:=Parent(f);
  Q:=CoefficientRing(P);
  R:=PolynomialRing(Q,Ngens(P),"grevlex");
  f:=R!f;

  numVars:=Ngens(R);
  df := [Derivative(f,i):i in [1..numVars]];
  J := IdealWithFixedBasis(df);

  // compute the pole order l of a homogeneous form p*Omega/f^l
  ell := func<p | (Degree(p)+Ngens(Parent(p)))/Degree(f)>;

  // to be used only for homogeneous forms
  function GDhom(p)
    // avoid division by zero
    if ell(p) eq 1 then
      return p,0; 
    end if;
    a:=NormalForm(p,J);
    B:=Coordinates(J,p-a);
    b := 1/(ell(p)-1)*&+[Derivative(B[i],i):i in [1..numVars]];
    return a,b;
  end function;

  // reduce a form p*Omega/f^l
  function GD(p)
    q:=R!0;
    repeat 
    pTop := HomogeneousComponent(p,Degree(p));
    a,b:=GDhom(pTop);
    p := p-pTop+b;
    q := q+a;
    until p eq (R!0);
    return q;
  end function;

  // to GD reduce a nested list of forms L
  function GDdeep(L,localDepth)
    if localDepth gt 0 then
      return [GDdeep(p,localDepth-1) : p in L];
    else
      return P!GD(R!L);
    end if;
  end function;

  return GDdeep(L,depth); 

end function;

//////////////////////////////
/// PicardFuchs equations  ///
//////////////////////////////

function PicardFuchs(f,forms)
  R:=Parent(f);
  K:=CoefficientRing(R);

  numVars:=Ngens(R);
  df := [Derivative(f,i):i in [1..numVars]];
  J := IdealWithFixedBasis(df);

  ell := func<p | (Degree(p)+Ngens(Parent(p)))/Degree(f)>;

  // to be used only for homogeneous forms
  function GDhom(p)
    // check if ell(p) = 1
    if ell(p) eq 1 then
      return p,0; 
    end if;
    a:=NormalForm(p,J);
    B:=Coordinates(J,p-a);
    b := 1/(ell(p)-1)*&+[Derivative(B[i],i):i in [1..numVars]];
    return a,b;
  end function;

  // reduce a form p*Omega/f^l
  function GD(p)
    q:=R!0;
    repeat 
      pTop := HomogeneousComponent(p,Degree(p));
      a,b:=GDhom(pTop);
      p := p-pTop+b;
      q := q+a;
    until p eq (R!0);
    return q;
  end function;
  // differentiate the coefficients
  function delT(p)
    c,m:=CoefficientsAndMonomials(p);
    dc:=[Derivative(o):o in c];
    return Polynomial(dc,m);
  end function;
  dtf := delT(f);
  // differentiate hom forms
  delTHomForm := func<a | delT(a) - ell(a)*dtf * a>;
  // differentiate the form p*Omega/f^l
  function delTForm(p)
    comps:=HomogeneousComponents(p);
    return &+[delTHomForm(c) : c in comps];
  end function;

  // The following ring is used only to store
  // the differential operators
  RR<D>:=PolynomialRing(K); 

  function PF(form : PFnumber:=0, TotalPFs:=0);
    reducedDerivatives:=[form];
    mons:=Monomials(reducedDerivatives[1]);
    print "Computing Picard-Fuchs equation number", PFnumber, "out of", TotalPFs;
    tstart:=Cputime();
    t2:="null";
    stopLoop:=false;
    repeat
      t0:=Cputime();
      if #reducedDerivatives gt 1 then
        printf "Checking independence took %o seconds. ", t0-t2;
      end if;
      lastDerivative:=delTForm(reducedDerivatives[#reducedDerivatives]);
      lastDerivativeReduced:=GD(lastDerivative);
      Append(~reducedDerivatives,lastDerivativeReduced);
      t1:=Cputime();
      printf "GD reduction took %o seconds. ", t1-t0;
      mons:= mons cat Monomials(reducedDerivatives[#reducedDerivatives]);
      if &+[Degree(a) : a in reducedDerivatives] eq 0 then
        stopLoop := #reducedDerivatives gt 1;
        t2:=Cputime();
      else
        L:=LinearSystem(Spec(R),mons);
        mu:=CoefficientMap(L);
        gens:=mu(reducedDerivatives);
        t2:=Cputime();
        stopLoop:=not IsIndependent(gens);
      end if;
    until stopLoop;

    t0:=Cputime();
    printf "Checking independence took %o seconds. ", t0-t2;
    print "Found linearly dependent derivatives in", t0-tstart, "seconds.";
    print "Will now compute the linear relation.";

    mon:=&join[Seqset(Monomials(a)):a in reducedDerivatives];
    mon:=Setseq(mon);
    MM:=[[MonomialCoefficient(a,m):m in mon]:a in reducedDerivatives];
    M:=Matrix(MM[1..(#MM-1)]);
    t1:=Cputime();
    printf "Computed the basismatrix in %o seconds. ", t1-t0;
    U:=VectorSpaceWithBasis(M);
    t2:=Cputime();
    printf "Constructed the vectorspace w/ basis in %o seconds. ", t2-t1;
    u:=U!MM[#MM];
    t3:=Cputime();
    printf "Computed the coordinates in %o seconds. ", t3-t2;
    coefs:=Append(Coordinates(U,-u),1);
    t4:=Cputime();
    print "Computing the linear relations took", t4-t0, "seconds.";
    print "The Picard-Fuchs equation number", PFnumber, "took", t4-tstart, "seconds to compute.";

    return &+[coefs[i]*D^(i-1):i in [1..#coefs]], reducedDerivatives;
  end function;

  PFeqns:=[RR|];
  derivativesOfForms:=[];

  for i in [1..#forms] do
    pf, dervs := PF(R!(forms[i]): PFnumber:=i, TotalPFs:=#forms);
    Append(~derivativesOfForms,dervs);
    Append(~PFeqns,pf);
  end for;

  return PFeqns,derivativesOfForms;

end function;

//// Part II : Computing initial conditions

// the monomial corresponding to alpha
// remember exponents are shifted
function monAlpha(alpha,R)
 N := #alpha;
 return &*[(R.i)^(alpha[i]-1) : i in [1..N]];
end function;

// input: the ambient ring, degree and type of the fermat curve 
// output: equation for the fermat curve
function Fermat(ring,degree,type)
  if #type eq 0 then 
    type := Append([1 : i in [1..(Ngens(ring)-1)]],-1); 
  end if;
  return &+[type[i]*(ring.i)^degree : i in [1..Ngens(ring)]];
end function;


// f1 is a homogenous polynomial over QQ
// we turn it into a family deforming from fermat of desired type
// unless f0 is specified
function setupFamily(f0,f1)
  R:=Parent(f0); 
  Q:=CoefficientRing(R);
  K<t>:=FunctionField(Q);
  R<[x]> := PolynomialRing(K,Ngens(R));
  return (1-t)*(R!f0) + t*(R!f1);
end function;


// f1 is a homogenous polynomial over QQ
// we turn it into a family deforming from fermat of desired type
// unless f0 is specified
//function setupFamily(f1: type :=[], f0:=0)
//  QQ:=RationalField();
//  K<t>:=FunctionField(QQ);
//  N:=Ngens(Parent(f1));
//  R<[x]> := PolynomialRing(K,N);
//  d:=Degree(f1);
//
//  if f0 eq 0 then
//    if #type eq 0 then type := defaultFermat(N); end if;
//    f0 := &+[type[i]*x[i]^d : i in [1..N]]; // Fermat
//  end if;
//
//  return (1-t)*(R!f0) + t*(R!f1);
//end function;

// differentiate a polynomial over a function field
// with respect to the parameter of that field
function delT(p)
  c,m:=CoefficientsAndMonomials(p);
  dc:=[Derivative(o):o in c];
  return Polynomial(dc,m);
end function;

// gives a function which takes a and differentiates a/f^l
// without bothering with the fractions
function fractionalDiff(f)
  dtf := delT(f);
  return func<a | delT(a) - dtf * a>; // this is free of any t, when the family is linear!
end function;

// returns the set A of alphas
// remember these are exponents shifted by one

function HoloExponents(n,deg)
  N:=n+2;
  L:={1..(deg-1)};
  LN:=[L:i in [1..N]];
  cp:=CartesianProduct(LN);
  return [[aa: aa in a]: a in cp | &+[u:u in a] eq deg];
end function;

function holoExponents(f)
  N:=Ngens(Parent(f));
  deg:=Degree(f);
  return HoloExponents(N-2,deg);
end function;

// given a monomial, compute its exponents increased by 1
function alpha(m)
  if  not IsMonomial(m) then error "Error: The function alpha requires a monomial as input"; end if;
  R:=Parent(m);
  return [Degree(m,j)+1 : j in [1..Ngens(R)]];
end function;

function PhamBasis(n,d)
// X is a hypersurface in P^(n+1) of degree d
// output always contains 0's on the last entries

  vars:=n+1;
  deg:=d;
  P<[x]>:=PolynomialRing(Rationals(),vars,"grevlex");
  x[#x + 1] := &*x;

  R<[y]>:=P/Ideal([&+[v^(r-1) : r in [1..deg]] : v in x]);
  V,psi:=VectorSpace(R);
  phi:=Inverse(psi);
  
  return [Append(Exponents(b),0) : b in phi(Basis(V))];
end function;

// homogenize a polynomial with respect to the last variable
function homogenize(f)
  if IsHomogeneous(f) then return f; end if;
  d := Degree(f);
  R := Parent(f);
  lastVar := R.Ngens(R);
  cof,mon := CoefficientsAndMonomials(f);
  newMon := [ m * lastVar^(d-Degree(m)) : m in mon];
  return &+[cof[i]*newMon[i] : i in [1..#cof]];
end function;

// works with a form of the type numerator*Omega/((1-t)*f0 + t*f1)^l
function differentiateForm(numerator,f0,f1)
  l:=(Degree(numerator)+Ngens(Parent(f0)))/Degree(f0);
  return -l*(f1-f0)*numerator;
end function;

// works with a form of the type numerator*Omega/((1-t)*f0 + t*f1)^l
function computeDerivatives(numerator,f0,f1,desiredDerivatives : withFactorial:=true)
  dervs:=[numerator];
  for i in [1..Maximum(desiredDerivatives)] do
    Append(~dervs,differentiateForm(dervs[i],f0,f1));
  end for;
  if withFactorial then
    return [ 1/Factorial(i) * dervs[i+1] : i in desiredDerivatives];
  else
    return [ dervs[i+1] : i in desiredDerivatives];
  end if;
end function;


// intersection matrix for pham cycles
forward cap;
function intersectionMatrix(n,d)
  B := PhamBasis(n,d);
  return [[cap(beta1,beta2,d) : beta2 in B] : beta1 in B];
end function;

//helper function
// b in [0..d-1]
function ee(b)
  if b eq 0 then 
    return 1; 
  elif b eq 1 then 
    return -1; 
  else 
    return 0;
  end if;
end function;

// Theorem 1.3 of Shimada
// note that beta's always have 0 at the last entry
// and this entry should be dropped when using these formulas
function cap(beta1,beta2,d)
  N := #beta1; // N := n+2;
  beta := [ (beta2[i] - beta1[i]) mod d : i in [1..(N-1)]];
  betaShift := [ (b+1) mod d : b in beta];
  return (-1)^(Integers()!((N-2)*(N-1)/2)) * (&*[ee(b) : b in beta] - &*[ee(b) : b in betaShift]);
end function;

function integrateMonomial(alpha,degree,phamBasis : type:=[], precision:=20)
  d:=degree;
  l:=Integers()!((&+alpha)/d);
  n:=#alpha-2;
  // Default to the standard fermat type
  if #type eq 0 then 
    type := Append([1 : i in [1..(n+1)]],-1); 
  end if;

  alphaX := alpha[1..(n+1)];
  ax:=alpha[n+2];

  CC<I>:=ComplexField(precision);
  AssignNames(~CC,["I"]);

  xi := Exp(2*Pi(CC)*I/d); // d-th root of unity
  prod:= &*([1] cat [ax-j*d : j in [1..(l-1)]]);
  c_dla:= (-1)^l/(Factorial(l-1) * d^l) * prod;
  mainTerm:= (-1/d)^n*&*[(1-xi^(-a))* Gamma(CC!(a/d)) : a in alphaX]/Gamma(&+[CC!(a/d) : a in alphaX]);

  // depending on the Fermat type we have to scale
  scl := CC!( &*[Root(type[j],d)^alpha[j] : j in [1..(#alpha-1)]] * Root(-type[#alpha],d)^alpha[#alpha])^(-1);

  dotProd:=func<beta |&+[alpha[j]*beta[j] : j in [1..(n+1)]]>;

  return [scl*c_dla*xi^dotProd(beta)*mainTerm : beta in phamBasis];

end function;

// input:
// dervs - a list of lists, entries are polynomials designating forms
// type - the type of the fermat curve over which we are integrating
// output:
// the integral of each form over the pham cycles in the fermat curve
function massIntegrate(dervs, deg, type : precision:=20)
  R:=Parent(dervs[1,1]);
  K:=CoefficientRing(R);
  n:=Ngens(R)-2; 
  // all monomials occuring in the entire collection
  mons:=Setseq(Seqset(&cat[Monomials(form) : form in &cat(dervs)]));
  alphas:=[[i+1: i in Exponents(m)] : m in mons];

  phamBasis:=PhamBasis(n,deg);
  CC<I>:=ComplexField(precision);
  V:=RSpace(CC,#phamBasis);
  integrals:=[V|integrateMonomial(alpha,deg,phamBasis : type:=type,precision:=precision) : alpha in alphas];

  function integrateForm(form)
    return Coordinates(V,&+[MonomialCoefficient(form,mons[i])*integrals[i]  : i in [1..#mons]]);
  end function;
  
  return [[ integrateForm(form) : form in dervs[j]] : j in [1..#dervs]];
end function;

//// Part III : Processing output


// The following three functions compare two period matricies of curves
// and finds the change of homology basis
function prepare(M : scale:=10^10)
  nrows:=#M;
  ncols:=#M[1];
  function realOrImaginary(i,j)
    ii:=Ceiling(i/2);
    if (i mod 2) eq 0 then return Im(M[ii,j]);
    else return Real(M[ii,j]); end if;
  end function;
  return [[Round(scale * realOrImaginary(i,j)) : j in [1..ncols] ] : i in [1..ncols]];
end function;

function preLLL(M,N : scale:=10^10)
  M:= Transpose(Matrix(prepare(M : scale:=scale)));
  N:= Transpose(Matrix(prepare(N : scale:=scale)));
  // M,N should now be integer square matricies of the same size
  s:=NumberOfColumns(M); 

  L := RMatrixSpace(IntegerRing(), 2*s, 3*s) ! 0;
  for i := 1 to 2*s do L[i,i + s] := 1; end for;
  for i := 1 to s do 
    for j := 1 to s do 
      L[i,j] := Round(M[i,j]); 
      L[i+s,j] := Round(N[i,j]); 
    end for;
  end for;

  return L;

end function;

// only intended for plane curves
function changeHomologyBasis(M,N : scale:=10^10)
  L:=preLLL(M,N : scale:=scale);
  LL:=LLL(L);
  s:=Integers()!(Nrows(LL)/2);
  B1:=Transpose(ExtractBlock(LL,1,s+1,s,s));
  B2:=-Transpose(ExtractBlock(LL,1,2*s+1,s,s));
  F:=Parent(M[1,1]);  
  b1:=ChangeRing(B1,F);
  b2:=ChangeRing(B2,F);
  b:=b2*Inverse(b1);
  ZB:=Matrix([[Round(b[i,j]) : j in [1..Ncols(b)]]: i in [1..Nrows(b)]]);
  B:=Matrix([[F|ZB[i,j] : j in [1..Ncols(b)]]: i in [1..Nrows(b)]]);
  errorRing<I>:=ComplexField(1);
  allErrors:=ElementToSequence(ChangeRing(Matrix(M) - Matrix(N)*B,errorRing));
  maximumError:=SquareRoot(Maximum([Norm(e): e in allErrors]));
  return ZB,maximumError,B;
end function;

// will only work if the solutions near 0 are all holomorphic
function localBasis(ode)
  K:=CoefficientRing(Parent(ode));  
  cK:=CoefficientRing(K);
  // universal univariate ring
  cofs:=Coefficients(ode);
  mons:=Monomials(ode);

  F := RationalDifferentialField(cK);
  AssignNames(~F,["z"]);
  newCofs:=[F!c : c in cofs];

  R := DifferentialOperatorRing(F);
  AssignNames(~R,["D"]);
  newMons:=[(R.1)^Degree(m) : m in mons];

  U<T>:=PolynomialRing(cK);
  newode:=&+[ newCofs[i]*newMons[i] : i in [1..#mons]];
  indPol:=IndicialPolynomial(newode, Zeros(F.1)[1]);
  facts:=[ fact[1] : fact in Factorisation(indPol)];

  if &or[ Degree(fact) gt 1 : fact in facts] then 
    error "Indicial polynomial does not factor into linear terms";
  end if;

  // the roots of the inidical polynomial
  exps:=[-Coefficient(fact,0) : fact in facts];
  // they should be positive integers
  check:=&and[IsCoercible(Integers(),e) and (e ge 0) : e in exps];
  if check then
    exps:=[Integers()| e : e in exps];
  else
    print ode;
    print exps;
    error "Indicial polynomial does not have positive integral roots";
  end if;

  return Reverse([ (K.1)^e : e in exps]), Reverse(exps); 
end function;

// input: K0, K1 two equi-dimensional subspaces of V
// output: 
// a 'simple' set of vectors generating V/K0 and V/K1
// simple means: either a basis of V or a sum of two basis elements of V
function findGoodBasis(V,K0,K1)
  if not (Dimension(K1) eq Dimension(K0)) then
    error "findGoodBasis can not be used with this input: quotients of different dimension"; 
  end if;

  if (Dimension(V) eq Dimension(K0)) then
    return [];
  end if;

  B:=Basis(V);
  goodBasis:=[];

  repeat 
    b0:=0; b1:=0; preference:=0;
    found:=false; i:=1;

    // try to find b that is neither in K0 or K1
    for b in B do
      if (b notin K0) and (b notin K1) then 
      found:=true;
      preference:=b;
      break;
      end if;
    end for;

    // otherwise find b that is not in K0 or K1 and mark it as such
    if not found then
      for b in B do
        if (b0 eq 0) and (b notin K0) then
          b0 := b; 
        end if;
        if (b1 eq 0) and (b notin K1) then
          b1 := b; 
        end if;
        if not (b0 eq 0 or b1 eq 0) then
          preference:=b0+b1;
          break;
        end if;
      end for;
    end if;

    K0:=K0 + sub<V|preference>;
    K1:=K1 + sub<V|preference>;
    Append(~goodBasis,preference);

  until Dimension(K0) eq Dimension(V);

  if not Dimension(K0) eq Dimension(K1) then
    error "a bug in goodBasis";
  end if;

  return goodBasis;

end function;

// find a basis for cohomology compatible for both f0 and f1
function computeCohomologyBasis(f0,f1)
  d:=Degree(f0);
  P:=Parent(f0);
  Q:=CoefficientRing(P);
  f1:=P!f1;
  
  // setting up the quotient maps to jacobi rings
  psis:=[**];
  for f in [f0,f1] do
    J:=Ideal([Derivative(f,i) : i in [1..Ngens(P)]]);
    assert 1 in Saturation(J); // f is smooth
    A:=quo<P|J>;
    V,psi:=VectorSpace(A);
    Append(~psis,psi);
  end for;

  // first setup the holomorphic forms
  if d lt Ngens(P) then
    basis := [];
  else
    basis:=[mon : mon in MonomialsOfDegree(P,d-Ngens(P))];
  end if;
  
  // admissable pole orders
  poles:=[l : l in [2..(Ngens(P)-1)] | l*d-Ngens(P) ge 0];
  // now find a basis of forms with higer pole order
  for l in poles do
    m:=l*d-Ngens(P);
    mons:=Setseq(MonomialsOfDegree(P,m));
    U:=VectorSpace(Rationals(),#mons);
    W:=[];
    // compute the two kernels from U to the Jacobi ring
    for psi in psis do
      mu:=hom<U->Codomain(psi)|[psi(m) : m in mons]>;
      Append(~W,Kernel(mu));
    end for;
    // find a simple basis of U which generates both quotient spaces
    // U/W[1] and U/W[2]
    basis := basis cat [P|&+[b[i]*mons[i]:i in [1..#mons]] : b in findGoodBasis(U,W[1],W[2])];
  end for;

  return basis;
end function;

// input: B1,B2 sets of polynomials, both of which provide a basis for cohomology
// output: write the basis B2 in the coordinates of B1
function changeCohomologyBasis(f,B1,B2)
  rB:=GriffithsDwork([*B1,B2*],f : depth:=2); 
  mons:=Setseq(Seqset(&cat[Monomials(b) : b in &cat(rB)]));
  rb1:=[[MonomialCoefficient(b,m) : m in mons] : b in rB[1]];
  rb2:=[[MonomialCoefficient(b,m) : m in mons] : b in rB[2]];
  W:=VectorSpaceWithBasis(Matrix(rb1));
  return [Coordinates(W,W!b) : b in rb2];
end function;

//input:
// B a basis for cohomology
// dervs a nested list of forms
// output:
// a nested list of row vectors, expressing the forms
// in terms of the basis
function coordinatesInCohomology(f,B,dervs)
  rB:=GriffithsDwork([*[B],dervs*],f : depth:=3); 
  mons:=Setseq(Seqset(&cat[Monomials(b) : b in &cat(&cat(rB))]));
  rb1:=[[MonomialCoefficient(b,m) : m in mons] : b in rB[1,1]];
  rb2:=[[[MonomialCoefficient(b,m) : m in mons] : b in bb] : bb in rB[2]];
  W:=VectorSpaceWithBasis(Matrix(rb1));
  return [[Coordinates(W,W!b) : b in bb] : bb in rb2];
end function;

//
// path breaking
//

function getTerm(g,m)
  return MonomialCoefficient(g,m)*m;
end function;

function isSmooth(f)
 return IsNonsingular(Scheme(Proj(Parent(f)),f));
end function;

function bestFermat(g)
  R:=Parent(g);
  d:=Degree(g); N:=Ngens(R);
  type:=[MonomialCoefficient(g,(R.i)^d) : i in [1..N]];
  zeros:=[i : i in [1..N] | type[i] eq 0];
  for i in zeros do
    type[i]:=1;
  end for;
  return Fermat(R,d,type);
end function;

function nextStep(f,g : randomize:=false)

  //if not isSmooth(g) then error("Target polynomial is not smooth."); end if;

  if f eq g then return g; end if;
  
  monsf:=Monomials(f);
  monsg:=Monomials(g);
  toSubtract:=Seqset([m: m in monsf | m notin monsg]);
  toAdd:=Seqset([m: m in monsg | m notin monsf]);
  common:=[m : m in monsg | m in monsf];
  toChange:=[m : m in common | not getTerm(f,m) eq getTerm(g,m)];

  if not #toChange eq 0 then
    if randomize then
      m:=Random(toChange);
    else
      m:=toChange[1];
    end if;
    return f - getTerm(f,m) + getTerm(g,m);
  end if;

  for j in [1..#toSubtract+#toAdd] do
    for i in [0..j] do
     subtract:=Subsets(toSubtract,j-i);
     add:=Subsets(toAdd,i);
     iterate:=[[*s,a*] : s in subtract, a in add];
     if randomize then
       shuffler:=[Random(100000) : i in [1..#iterate]];
       ParallelSort(~shuffler,~iterate);
     end if;
     for mons in iterate do
      ss:=&+([0] cat [getTerm(f,m) : m in mons[1]]);
      aa:=&+([0] cat [getTerm(g,m) : m in mons[2]]);
      h:=f-ss+aa;
      if isSmooth(h) then return h; end if;
     end for;
    end for;
  end for;
end function;

function breakingPath(g1 : randomize:=false, g0:=bestFermat(g1))
  steps:=[g0];
  repeat
    h:=nextStep(steps[#steps],g1 : randomize:=randomize);
    Append(~steps,h);
  until h eq g1;
  return steps;
end function;

// Warning: incorporate this into periodbundle
load "pathFinder.mag";

//Warning: change default filename
//Warning: check if the input polynomials are homogeneous and smooth
function periodBundle(path : precision:=200, straight:=false, filename:="magmaOutput", lairez:=false, periodsOnly:=true, randomizePath:=true, pathfinder:=false) 

  print "\nSetting up the path, cohomology bases and transition matricies...\n";

  target:=path[#path]; 
  P:=Parent(target);
  d:=Degree(target); 
  n:=Ngens(P)-2;

  if straight then
    if #path eq 1 then
      path:=[bestFermat(target),target];
    elif #path gt 2 then
      print "A straight path is requested with a list of more than 2 polynomials. Ignoring intermediate terms.";
      path:=[path[1],path[#path]];
    end if;
  elif #path eq 1 then 
    path:=breakingPath(path[1] : randomize:=randomizePath); 
  end if;

  families:=[*setupFamily(path[i],path[i+1]): i in [1..(#path-1)]*];

  if periodsOnly then
    if d-n-2 lt 0 then Error("The variety has no holomorphic forms. Set the option periodsOnly to false if you want to compute the entire cohomology pairing."); end if;
    bases:=[*computeCohomologyBasis(path[i],path[i+1]): i in [1..(#path-2)]*] cat [*[mon : mon in MonomialsOfDegree(P,d-n-2)]*];
  else
    bases:=[*computeCohomologyBasis(path[i],path[i+1]): i in [1..(#path-1)]*];
  end if;

  if lairez then
    picfuchs:=lairezPicardFuchs;
  else
    picfuchs:=PicardFuchs;
  end if;

pathMons:=[#Monomials(p) : p in path];
pathMonsChange:=[#Monomials(path[j]-path[j-1]) : j in [2..#path]];

print "Using the following path:",path;
print "The number of monomials appearing at each step:\n",pathMons;
print "The number of monomials that are changed at each step:\n",pathMonsChange;

  relevantDerivatives:=[];
  allODEs:=[];
  for i in [1..#families] do
    relDers:=[];
    print "\nWe are at family number",i,"out of",#families,"\n";
    odes:=picfuchs(families[i],bases[i]);
    for j in [1..#odes] do
      _,requiredDerivatives := localBasis(odes[j]);
      Append(~relDers,computeDerivatives(bases[i,j],path[i],path[i+1],requiredDerivatives : withFactorial:=true));
    end for;
    Append(~relevantDerivatives,relDers);
    Append(~allODEs,odes);
  end for;

  // the initial conditions for the first family
  initialConditions:=massIntegrate(relevantDerivatives[1],Degree(path[1]),Coefficients(path[1]) : precision:=precision); 
  // the change of coordinates necessary to setup initial conditions for later families
  coords:=[];
  for i in [2..#families] do
    coord:=coordinatesInCohomology(path[i],bases[i-1],relevantDerivatives[i]);
    Append(~coords,coord);
  end for;

  // WARNING: path finder needs to be loaded first
  if pathfinder then
    integrationPaths2d:=pathFinder(allODEs);
    Cc:=ComplexField(10);
    AssignNames(~Cc,["I"]);
    integrationPaths:=[];
    for p2d in integrationPaths2d do
      integrationPath := [Sprint(pt[1] + pt[2]*Cc.1) : pt in p2d ];
      integrationPath[1]:=Sprint(0);
      integrationPath[#integrationPath]:=Sprint(1);
      Append(~integrationPaths,integrationPath);
    end for;
  else
    integrationPaths:=[];
  end if;

  file:=filename*".mag";
  Write(file,"geometricGenus="*Sprint(Binomial(d-1,n+1)) : Overwrite:=true);
  Write(file,"periodsOnly="*Sprint(periodsOnly));
  Write(file,"paths="*Sprint(integrationPaths));
  Write(file,"rawInits="*Sprint(coords));
  Write(file,"inits="*Sprint(initialConditions));
  Write(file,"allODEs="*Sprint(allODEs));
  Write(file,"#deformationPath:="*Sprint(path));

  System("$(which awk) -f convert.awk "*file*" > current.sage");

  Write("current.sage","periodsOnly="*Sprint(periodsOnly));


pathMons:=[#Monomials(p) : p in path];
pathMonsChange:=[#Monomials(path[j]-path[j-1]) : j in [2..#path]];

print "Used the following path:",path;
print "The number of monomials appearing at each step:\n",pathMons;
print "The number of monomials that are changed at each step:\n",pathMonsChange;

  
  return [*path,coords,initialConditions,allODEs*];
end function;

// input: list of lists of ODEs
// order: order and degree of the ODEs
function analytics(allODEs);
  res:=[];
  for odes in allODEs do
    subres:=[];
    for ode in odes do
      code:=Coefficients(ode);
      codeN:=[Numerator(c) : c in code];
      codeD:=LCM([Denominator(c) : c in code]);
      cofs:=codeN cat [codeD];
      degs:=[Degree(c) : c in cofs];
      Append(~subres,[Degree(ode),Max(degs)]);
    end for;
    Append(~res,subres);
  end for;
  return res;
end function;

// input: f0,f1 two hom polys of same degree
// output: the values of t for which the hypersurface (1-t)*f0+t*f1 is singular
// assuming general fiber is smooth
function singularFibersOfPencil(f0,f1:KK:=ComplexField(20))
  P:=Parent(f0);
  R<t>:=PolynomialRing(Rationals(),Ngens(P)+1,"elim",1);
  inc:=hom<P->R|[R.i : i in [2..Ngens(R)]]>;
  F:=(1-t)*inc(f0)+t*inc(f1);
  I:=ideal<R|[Derivative(F,i): i in [2..Ngens(R)]]>;
  J:=ideal<R|[R.i : i in [2..Ngens(R)]]>;
  IJ:=Saturation(I,J);
  gb:=GroebnerBasis(IJ);
  polys:=[p : p in gb | IsUnivariate(p,t)];
  rts:=[KK|];
  for p in polys do
    _,h:=IsUnivariate(p);
    rts:=rts cat [r[1] : r in Roots(h,KK)];
  end for;
  return rts;
end function;
