//// Part I : Computing the Picard-Fuchs equations

////////////////////////////////
/// GriffithsDwork reduction ///
////////////////////////////////


// input: 
// L a nested list of polynomials
// f defines a smooth hypersurface
// depth is the nesting depth of L 
// output:
// GD reduction of polynomials of L wrt f
// in the same nesting structure of L
function GriffithsDwork(L,f : depth:=0)
  P:=Parent(f);
  Q:=CoefficientRing(P);
  R:=PolynomialRing(Q,Ngens(P),"grevlex");
  f:=R!f;

  numVars:=Ngens(R);
  df := [Derivative(f,i):i in [1..numVars]];
  J := IdealWithFixedBasis(df);

  // compute the pole order l of a homogeneous form p*Omega/f^l
  ell := func<p | (Degree(p)+Ngens(Parent(p)))/Degree(f)>;

  // to be used only for homogeneous forms
  function GDhom(p)
    // avoid division by zero
    if ell(p) eq 1 then
      return p,0; 
    end if;
    a:=NormalForm(p,J);
    B:=Coordinates(J,p-a);
    b := 1/(ell(p)-1)*&+[Derivative(B[i],i):i in [1..numVars]];
    return a,b;
  end function;

  // reduce a form p*Omega/f^l
  function GD(p)
    q:=R!0;
    repeat 
    pTop := HomogeneousComponent(p,Degree(p));
    a,b:=GDhom(pTop);
    p := p-pTop+b;
    q := q+a;
    until p eq (R!0);
    return q;
  end function;

  // to GD reduce a nested list of forms L
  function GDdeep(L,localDepth)
    if localDepth gt 0 then
      return [GDdeep(p,localDepth-1) : p in L];
    else
      return P!GD(R!L);
    end if;
  end function;

  return GDdeep(L,depth); 

end function;

//////////////////////////////
/// PicardFuchs equations  ///
//////////////////////////////

function PicardFuchs(f,forms)
  R:=Parent(f);
  K:=CoefficientRing(R);

  numVars:=Ngens(R);
  df := [Derivative(f,i):i in [1..numVars]];
  J := IdealWithFixedBasis(df);

  ell := func<p | (Degree(p)+Ngens(Parent(p)))/Degree(f)>;

  // to be used only for homogeneous forms
  function GDhom(p)
    // check if ell(p) = 1
    if ell(p) eq 1 then
      return p,0; 
    end if;
    a:=NormalForm(p,J);
    B:=Coordinates(J,p-a);
    b := 1/(ell(p)-1)*&+[Derivative(B[i],i):i in [1..numVars]];
    return a,b;
  end function;

  // reduce a form p*Omega/f^l
  function GD(p)
    q:=R!0;
    repeat 
      pTop := HomogeneousComponent(p,Degree(p));
      a,b:=GDhom(pTop);
      p := p-pTop+b;
      q := q+a;
    until p eq (R!0);
    return q;
  end function;
  // differentiate the coefficients
  function delT(p)
    c,m:=CoefficientsAndMonomials(p);
    dc:=[Derivative(o):o in c];
    return Polynomial(dc,m);
  end function;
  dtf := delT(f);
  // differentiate hom forms
  delTHomForm := func<a | delT(a) - ell(a)*dtf * a>;
  // differentiate the form p*Omega/f^l
  function delTForm(p)
    comps:=HomogeneousComponents(p);
    return &+[delTHomForm(c) : c in comps];
  end function;

  // The following ring is used only to store
  // the differential operators
  RR<D>:=PolynomialRing(K); 

  function PF(form : PFnumber:=0, TotalPFs:=0);
    reducedDerivatives:=[form];
    mons:=Monomials(reducedDerivatives[1]);
    print "\nComputing Picard-Fuchs equation number", PFnumber, "out of", TotalPFs,"\n";
    tstart:=Cputime();
    t2:="null";
    stopLoop:=false;
    repeat
      t0:=Cputime();
      if #reducedDerivatives gt 1 then
        printf "Checking independence took %o seconds. ", t0-t2;
      end if;
      lastDerivative:=delTForm(reducedDerivatives[#reducedDerivatives]);
      lastDerivativeReduced:=GD(lastDerivative);
      Append(~reducedDerivatives,lastDerivativeReduced);
      t1:=Cputime();
      printf "GD reduction took %o seconds. ", t1-t0;
      mons:= mons cat Monomials(reducedDerivatives[#reducedDerivatives]);
      if &+[Degree(a) : a in reducedDerivatives] eq 0 then
        stopLoop := #reducedDerivatives gt 1;
        t2:=Cputime();
      else
        L:=LinearSystem(Spec(R),mons);
        mu:=CoefficientMap(L);
        gens:=mu(reducedDerivatives);
        t2:=Cputime();
        stopLoop:=not IsIndependent(gens);
      end if;
    until stopLoop;

    t0:=Cputime();
    printf "Checking independence took %o seconds. ", t0-t2;
    print "Found linearly dependent derivatives in", t0-tstart, "seconds.";
    print "Will now compute the linear relation.";

    mon:=&join[Seqset(Monomials(a)):a in reducedDerivatives];
    mon:=Setseq(mon);
    MM:=[[MonomialCoefficient(a,m):m in mon]:a in reducedDerivatives];
    M:=Matrix(MM[1..(#MM-1)]);
    t1:=Cputime();
    printf "Computed the basismatrix in %o seconds. ", t1-t0;
    U:=VectorSpaceWithBasis(M);
    t2:=Cputime();
    printf "Constructed the vectorspace w/ basis in %o seconds. ", t2-t1;
    u:=U!MM[#MM];
    t3:=Cputime();
    printf "Computed the coordinates in %o seconds. ", t3-t2;
    coefs:=Append(Coordinates(U,-u),1);
    t4:=Cputime();
    print "Computing the linear relations took", t4-t0, "seconds.";
    print "The Picard-Fuchs equation number", PFnumber, "took", t4-tstart, "seconds to compute.";

    return &+[coefs[i]*D^(i-1):i in [1..#coefs]], reducedDerivatives;
  end function;

  PFeqns:=[RR|];
  derivativesOfForms:=[];

  for i in [1..#forms] do
    pf, dervs := PF(R!(forms[i]): PFnumber:=i, TotalPFs:=#forms);
    Append(~derivativesOfForms,dervs);
    Append(~PFeqns,pf);
  end for;

  return PFeqns,derivativesOfForms;

end function;

//// Part II : Computing initial conditions

// the monomial corresponding to alpha
// remember exponents are shifted
function monAlpha(alpha,R)
 N := #alpha;
 return &*[(R.i)^(alpha[i]-1) : i in [1..N]];
end function;

// input: the ambient ring, degree and type of the fermat curve 
// output: equation for the fermat curve
function Fermat(ring,degree,type)
  if #type eq 0 then 
    type := Append([1 : i in [1..(Ngens(ring)-1)]],-1); 
  end if;
  return &+[type[i]*(ring.i)^degree : i in [1..Ngens(ring)]];
end function;


// f1 is a homogenous polynomial over QQ
// we turn it into a family deforming from fermat of desired type
// unless f0 is specified
function SetupFamily(f0,f1)
  R:=Parent(f0); 
  Q:=CoefficientRing(R);
  K<t>:=FunctionField(Q);
  R<[x]> := PolynomialRing(K,Ngens(R));
  return (1-t)*(R!f0) + t*(R!f1);
end function;


// differentiate a polynomial over a function field
// with respect to the parameter of that field
function delT(p)
  c,m:=CoefficientsAndMonomials(p);
  dc:=[Derivative(o):o in c];
  return Polynomial(dc,m);
end function;

// gives a function which takes a and differentiates a/f^l
// without bothering with the fractions
function fractionalDiff(f)
  dtf := delT(f);
  return func<a | delT(a) - dtf * a>; // this is free of any t, when the family is linear!
end function;

// returns the set A of alphas
// remember these are exponents shifted by one

function HoloExponents(n,deg)
  N:=n+2;
  L:={1..(deg-1)};
  LN:=[L:i in [1..N]];
  cp:=CartesianProduct(LN);
  return [[aa: aa in a]: a in cp | &+[u:u in a] eq deg];
end function;

function holoExponents(f)
  N:=Ngens(Parent(f));
  deg:=Degree(f);
  return HoloExponents(N-2,deg);
end function;

// given a monomial, compute its exponents increased by 1
function alpha(m)
  if  not IsMonomial(m) then error "Error: The function alpha requires a monomial as input"; end if;
  R:=Parent(m);
  return [Degree(m,j)+1 : j in [1..Ngens(R)]];
end function;

function PhamBasis(n,d)
// X is a hypersurface in P^(n+1) of degree d
// output always contains 0's on the last entries

  vars:=n+1;
  deg:=d;
  P<[x]>:=PolynomialRing(Rationals(),vars,"grevlex");
  x[#x + 1] := &*x;

  R<[y]>:=P/Ideal([&+[v^(r-1) : r in [1..deg]] : v in x]);
  V,psi:=VectorSpace(R);
  phi:=Inverse(psi);
  
  return [Append(Exponents(b),0) : b in phi(Basis(V))];
end function;

// homogenize a polynomial with respect to the last variable
function homogenize(f)
  if IsHomogeneous(f) then return f; end if;
  d := Degree(f);
  R := Parent(f);
  lastVar := R.Ngens(R);
  cof,mon := CoefficientsAndMonomials(f);
  newMon := [ m * lastVar^(d-Degree(m)) : m in mon];
  return &+[cof[i]*newMon[i] : i in [1..#cof]];
end function;

// works with a form of the type numerator*Omega/((1-t)*f0 + t*f1)^l
function differentiateForm(numerator,f0,f1)
  l:=(Degree(numerator)+Ngens(Parent(f0)))/Degree(f0);
  return -l*(f1-f0)*numerator;
end function;

// works with a form of the type numerator*Omega/((1-t)*f0 + t*f1)^l
function computeDerivatives(numerator,f0,f1,desiredDerivatives : withFactorial:=true)
  dervs:=[numerator];
  for i in [1..Maximum(desiredDerivatives)] do
    Append(~dervs,differentiateForm(dervs[i],f0,f1));
  end for;
  if withFactorial then
    return [ 1/Factorial(i) * dervs[i+1] : i in desiredDerivatives];
  else
    return [ dervs[i+1] : i in desiredDerivatives];
  end if;
end function;


//helper function
// b in [0..d-1]
function ee(b)
  if b eq 0 then 
    return 1; 
  elif b eq 1 then 
    return -1; 
  else 
    return 0;
  end if;
end function;

// Theorem 1.3 of Shimada
// note that beta's always have 0 at the last entry
// and this entry should be dropped when using these formulas
function cap(beta1,beta2,d)
  N := #beta1; // N := n+2;
  beta := [ (beta2[i] - beta1[i]) mod d : i in [1..(N-1)]];
  betaShift := [ (b+1) mod d : b in beta];
  return (-1)^(Integers()!((N-2)*(N-1)/2)) * (&*[ee(b) : b in beta] - &*[ee(b) : b in betaShift]);
end function;

// intersection matrix for pham cycles
function PhamIntersectionMatrix(n,d)
  B := PhamBasis(n,d);
  return [[cap(beta1,beta2,d) : beta2 in B] : beta1 in B];
end function;

// intersection matrix for pham cycles, from basis
function PhamIntersectionMatrixFromBasis(B,d)
  return [[cap(beta1,beta2,d) : beta2 in B] : beta1 in B];
end function;

// this function is now obsolete!!
// it is here only for readability
function integrateMonomial(alpha,degree,phamBasis : type:=[], precision:=20)
  d:=degree;
  l:=Integers()!((&+alpha)/d);
  n:=#alpha-2;
  // Default to the standard fermat type
  if #type eq 0 then 
    type := Append([1 : i in [1..(n+1)]],-1); 
  end if;

  alphaX := alpha[1..(n+1)];
  ax:=alpha[n+2];

  CC<I>:=ComplexField(precision);
  AssignNames(~CC,["I"]);

  xi := Exp(2*Pi(CC)*I/d); // d-th root of unity
  prod:= &*([1] cat [ax-j*d : j in [1..(l-1)]]);
  c_dla:= (-1)^l/(Factorial(l-1) * d^l) * prod;
  mainTerm:= (-1/d)^n*&*[(1-xi^(-a))* Gamma(CC!(a/d)) : a in alphaX]/Gamma(&+[CC!(a/d) : a in alphaX]);

  // depending on the Fermat type we have to scale
  scl := 1/( &*[Root(CC!type[j],d)^alpha[j] : j in [1..(#alpha-1)]] * Root(CC!-type[#alpha],d)^alpha[#alpha]);

  dotProd:=func<beta |&+[alpha[j]*beta[j] : j in [1..(n+1)]]>;

  return [scl*c_dla*xi^dotProd(beta)*mainTerm : beta in phamBasis];

end function;


// optimized for very high genus curves, but rendered unreadable
// please look at integrateMonomial for a readable version
function integrateMonomials(alphas,degree,phamBasis : type:=[], precision:=20)
  d:=degree;
  n:=#(alphas[1])-2;
  if #type eq 0 then 
    type := Append([1 : i in [1..(n+1)]],-1); 
  end if;
  CC<I>:=ComplexField(precision);
  AssignNames(~CC,["I"]);
  xi := Exp(2*Pi(CC)*I/d); // d-th root of unity
  rootsOfType:=[Root(CC!type[i],d) : i in [1..(#type-1)]] cat [Root(CC!(-type[#type]),d)];


  // setting up the "empty" list
  integrals:=[[CC|0 : beta in phamBasis] : alpha in alphas];
  // store computed gamma values for efficiency
  gammaValues:=[CC|0 : i in [1..5000]];
  for u in [1..#alphas] do
    printf "\nIntegrating monomial number %o out of %o", u, #alphas;
    alpha:=alphas[u];
    l:=Integers()!((&+alpha)/d);
    // Default to the standard fermat type
    alphaX := alpha[1..(n+1)];
    ax:=alpha[n+2];

    prod:= &*([1] cat [ax-j*d : j in [1..(l-1)]]);
    c_dla:= (-1)^l/(Factorial(l-1) * d^l) * prod;

    vals:=alphaX cat [&+[a : a in alphaX]];
    for a in vals do
      if (not IsDefined(gammaValues,a)) or (gammaValues[a] eq 0) then
        gammaValues[a]:=Gamma(CC!(a/d));
      end if;
    end for;

    mainTerm:= (-1/d)^n*&*[(1-xi^(-a))*gammaValues[a] : a in alphaX]/gammaValues[&+[a : a in alphaX]];

    // depending on the Fermat type we have to scale
    scl := 1/( &*[rootsOfType[j]^alpha[j] : j in [1..#alpha]]);
    dotProd:=func<beta |&+[alpha[j]*beta[j] : j in [1..(n+1)]]>;

    integrals[u]:=[scl*c_dla*xi^dotProd(beta)*mainTerm : beta in phamBasis];
  end for;

  return integrals;

end function;

// input:
// dervs - a list of lists, entries are polynomials designating forms
// type - the type of the fermat curve over which we are integrating
// output:
// the integral of each form over the pham cycles in the fermat curve
function massIntegrate(dervs, deg, type : precision:=20)
  R:=Parent(dervs[1,1]);
  K:=CoefficientRing(R);
  n:=Ngens(R)-2; 
  // all monomials occuring in the entire collection
  mons:=Setseq(Seqset(&cat[Monomials(form) : form in &cat(dervs)]));
  alphas:=[[i+1: i in Exponents(m)] : m in mons];

  print "Constructing a Pham basis and its intersection matrix.";
  phamBasis:=PhamBasis(n,deg);
  CC<I>:=ComplexField(precision);
  intmat:=PhamIntersectionMatrixFromBasis(phamBasis,deg);
  print "Construction complete";
  V:=RSpace(CC,#phamBasis);
  integrals:=integrateMonomials(alphas,deg,phamBasis : type:=type,precision:=precision);
  //integrals:=[V|integrateMonomial(alpha,deg,phamBasis : type:=type,precision:=precision) : alpha in alphas];
  print "\nIntegrated monomials.";
  integrals:=[V| period : period in integrals];
  print "Converted the integrals to vectors.";

  print "Now adding the integrals of monomials for each polynomial.";
  result:=[[[] : u in derv ] : derv in dervs];
  for j in [1..#dervs] do
    printf "\nPutting together monomial integrals of form %o in %o", j, #dervs;
    for i in [1..#(dervs[j])] do
      indexSet:=[Index(mons,m) : m in Monomials(dervs[j,i])];
      result[j,i]:=Coordinates(V,&+[MonomialCoefficient(dervs[j,i],mons[mm])*integrals[mm]  : mm in indexSet]);
    end for;
  end for;
  
  return result,intmat,phamBasis;
end function;

//// Part III : Main function, transition matricies, post processing

// The following three functions compare two period matricies of curves
// and finds the change of homology basis
function prepare(M : scale:=10^10)
  nrows:=#M;
  ncols:=#M[1];
  function realOrImaginary(i,j)
    ii:=Ceiling(i/2);
    if (i mod 2) eq 0 then return Im(M[ii,j]);
    else return Real(M[ii,j]); end if;
  end function;
  return [[Round(scale * realOrImaginary(i,j)) : j in [1..ncols] ] : i in [1..(2*nrows)]];
end function;

function preLLL(M,N : scale:=10^10)
  M:= Transpose(Matrix(prepare(M : scale:=scale)));
  N:= Transpose(Matrix(prepare(N : scale:=scale)));
  // M,N should now be integer square matricies of the same size
  cm:=NumberOfColumns(M); 
  rm:=NumberOfRows(M);
  cn:=NumberOfColumns(N);
  rn:=NumberOfRows(N);
  
  assert cm eq cn;

  L := RMatrixSpace(Integers(), rm+rn, cm+rm+rn) ! 0;
  one:=One(MatrixAlgebra(Integers(),rm+rn));
  InsertBlock(~L,one,1,cm+1); 
  InsertBlock(~L,M,1,1);
  InsertBlock(~L,N,rm+1,1);

  return L;
end function;

//M , N matricies with the same number of rows
// permute = integer sequence, recording how to reorder rows of N : eg. [2,3,1] means first row should go to second row, second row to third and first row to first.
// if reverse = true then we set permute:=[n,n-1,...,1]
function ChangeHomologyBasis(M,N : reverse:=false, permute:=[], digits:=20)
  F:=Parent(M[1,1]);  
  cm:=NumberOfColumns(M); 
  rm:=NumberOfRows(M);
  cn:=NumberOfColumns(N);
  // number of rows of M and N are assumed equal
  // preLLL will check this

  // permute the rows of N
  if reverse then
    permute:=[rm..1 by -1]; 
  end if;
  if #permute eq rm then
   sigma:=Sym(rm)!permute; 
   // transpose to get the action on the left
   permMat:=Transpose(PermutationMatrix(F,sigma));
   N:=permMat*N;
  end if;

  scale:=10^digits;
  L:=preLLL(RowSequence(M),RowSequence(N) : scale:=scale);
  LL:=LLL(L);

  B1:=Transpose(ExtractBlock(LL,1,2*rm+1,cm,cm));
  B2:=-Transpose(ExtractBlock(LL,1,2*rm+cm+1,cn,cn));
  b1:=ChangeRing(B1,F);
  b2:=ChangeRing(B2,F);
  b:=b2*Inverse(b1);
  ZB:=Matrix([[Round(b[i,j]) : j in [1..Ncols(b)]]: i in [1..Nrows(b)]]);
  B:=Matrix([[F|ZB[i,j] : j in [1..Ncols(b)]]: i in [1..Nrows(b)]]);
  errorRing<I>:=ComplexField(1);

  // WARNING: Scaling the error to exaggerate size.
  allErrors:=ElementToSequence(ChangeRing(scale*(Matrix(M) - Matrix(N)*B),errorRing));
  maximumError:=SquareRoot(Maximum([Norm(e): e in allErrors]));
  print "\nEngineered error should be around 1, anything less is an indication of a stronger match. If there is no match, expect an error of 10^"*Sprint(digits)*".\n";
  print "Obtained an error of:", maximumError, "\n";

  return ZB,maximumError,B;
end function;


// will only work if the solutions near 0 are all holomorphic
function localBasis(ode)
  K:=CoefficientRing(Parent(ode));  
  cK:=CoefficientRing(K);
  // universal univariate ring
  cofs:=Coefficients(ode);
  mons:=Monomials(ode);

  F := RationalDifferentialField(cK);
  AssignNames(~F,["z"]);
  newCofs:=[F!c : c in cofs];

  R := DifferentialOperatorRing(F);
  AssignNames(~R,["D"]);
  newMons:=[(R.1)^Degree(m) : m in mons];

  U<T>:=PolynomialRing(cK);
  newode:=&+[ newCofs[i]*newMons[i] : i in [1..#mons]];
  indPol:=IndicialPolynomial(newode, Zeros(F.1)[1]);
  facts:=[ fact[1] : fact in Factorisation(indPol)];

  if &or[ Degree(fact) gt 1 : fact in facts] then 
    error "Indicial polynomial does not factor into linear terms";
  end if;

  // the roots of the inidical polynomial
  exps:=[-Coefficient(fact,0) : fact in facts];
  // they should be positive integers
  check:=&and[IsCoercible(Integers(),e) and (e ge 0) : e in exps];
  if check then
    exps:=[Integers()| e : e in exps];
  else
    print ode;
    print exps;
    error "Indicial polynomial does not have positive integral roots";
  end if;

  return Reverse([ (K.1)^e : e in exps]), Reverse(exps); 
end function;

// input: K0, K1 two equi-dimensional subspaces of V
// output: 
// a 'simple' set of vectors generating V/K0 and V/K1
// simple means: either a basis of V or a sum of two basis elements of V
function findGoodBasis(V,K0,K1)
  if not (Dimension(K1) eq Dimension(K0)) then
    error "findGoodBasis can not be used with this input: quotients of different dimension"; 
  end if;

  if (Dimension(V) eq Dimension(K0)) then
    return [];
  end if;

  B:=Basis(V);
  goodBasis:=[];

  repeat 
    b0:=0; b1:=0; preference:=0;
    found:=false; i:=1;

    // try to find b that is neither in K0 or K1
    for b in B do
      if (b notin K0) and (b notin K1) then 
      found:=true;
      preference:=b;
      break;
      end if;
    end for;

    // otherwise find b that is not in K0 or K1 and mark it as such
    if not found then
      for b in B do
        if (b0 eq 0) and (b notin K0) then
          b0 := b; 
        end if;
        if (b1 eq 0) and (b notin K1) then
          b1 := b; 
        end if;
        if not (b0 eq 0 or b1 eq 0) then
          preference:=b0+b1;
          break;
        end if;
      end for;
    end if;

    K0:=K0 + sub<V|preference>;
    K1:=K1 + sub<V|preference>;
    Append(~goodBasis,preference);

  until Dimension(K0) eq Dimension(V);

  if not Dimension(K0) eq Dimension(K1) then
    error "a bug in goodBasis";
  end if;

  return goodBasis;

end function;

// find a basis for cohomology compatible for both f0 and f1
function ComputeCohomologyBasis(f0,f1)
  d:=Degree(f0);
  P:=Parent(f0);
  Q:=CoefficientRing(P);
  f1:=P!f1;
  
  // setting up the quotient maps to jacobi rings
  psis:=[**];
  for f in [f0,f1] do
    J:=Ideal([Derivative(f,i) : i in [1..Ngens(P)]]);
    assert 1 in Saturation(J); // f is smooth
    A:=quo<P|J>;
    V,psi:=VectorSpace(A);
    Append(~psis,psi);
  end for;

  // first setup the holomorphic forms
  if d lt Ngens(P) then
    basis := [];
  else
    basis:=[mon : mon in MonomialsOfDegree(P,d-Ngens(P))];
  end if;
  
  // admissable pole orders
  poles:=[l : l in [2..(Ngens(P)-1)] | l*d-Ngens(P) ge 0];
  // now find a basis of forms with higer pole order
  for l in poles do
    m:=l*d-Ngens(P);
    mons:=Setseq(MonomialsOfDegree(P,m));
    U:=VectorSpace(Rationals(),#mons);
    W:=[];
    // compute the two kernels from U to the Jacobi ring
    for psi in psis do
      mu:=hom<U->Codomain(psi)|[psi(m) : m in mons]>;
      Append(~W,Kernel(mu));
    end for;
    // find a simple basis of U which generates both quotient spaces
    // U/W[1] and U/W[2]
    basis := basis cat [P|&+[b[i]*mons[i]:i in [1..#mons]] : b in findGoodBasis(U,W[1],W[2])];
  end for;

  return basis;
end function;

// input: B1,B2 sets of polynomials, both of which provide a basis for cohomology
// output: write the basis B2 in the coordinates of B1
function changeCohomologyBasis(f,B1,B2)
  rB:=GriffithsDwork([*B1,B2*],f : depth:=2); 
  mons:=Setseq(Seqset(&cat[Monomials(b) : b in &cat(rB)]));
  rb1:=[[MonomialCoefficient(b,m) : m in mons] : b in rB[1]];
  rb2:=[[MonomialCoefficient(b,m) : m in mons] : b in rB[2]];
  W:=VectorSpaceWithBasis(Matrix(rb1));
  return [Coordinates(W,W!b) : b in rb2];
end function;

//input:
// B a basis for cohomology
// dervs a nested list of forms
// output:
// a nested list of row vectors, expressing the forms
// in terms of the basis
function coordinatesInCohomology(f,B,dervs)
  rB:=GriffithsDwork([*[B],dervs*],f : depth:=3); 
  mons:=Setseq(Seqset(&cat[Monomials(b) : b in &cat(&cat(rB))]));
  rb1:=[[MonomialCoefficient(b,m) : m in mons] : b in rB[1,1]];
  rb2:=[[[MonomialCoefficient(b,m) : m in mons] : b in bb] : bb in rB[2]];
  W:=VectorSpaceWithBasis(Matrix(rb1));
  return [[Coordinates(W,W!b) : b in bb] : bb in rb2];
end function;

//
// path breaking
//

function getTerm(g,m)
  return MonomialCoefficient(g,m)*m;
end function;

function isSmooth(f)
 return IsNonsingular(Scheme(Proj(Parent(f)),f));
end function;

function BestFermat(g)
  R:=Parent(g);
  d:=Degree(g); N:=Ngens(R);
  type:=[MonomialCoefficient(g,(R.i)^d) : i in [1..N]];
  zeros:=[i : i in [1..N] | type[i] eq 0];
  for i in zeros do
    type[i]:=1;
  end for;
  return Fermat(R,d,type);
end function;

function nextStep(f,g : randomize:=false)

  if f eq g then return g; end if;
  
  monsf:=Monomials(f);
  monsg:=Monomials(g);
  toSubtract:=Seqset([m: m in monsf | m notin monsg]);
  toAdd:=Seqset([m: m in monsg | m notin monsf]);
  common:=[m : m in monsg | m in monsf];
  toChange:=[m : m in common | not getTerm(f,m) eq getTerm(g,m)];

  if not #toChange eq 0 then
    if randomize then
      m:=Random(toChange);
    else
      m:=toChange[1];
    end if;
    return f - getTerm(f,m) + getTerm(g,m);
  end if;

  for j in [1..#toSubtract+#toAdd] do
    for i in [0..j] do
     subtract:=Subsets(toSubtract,j-i);
     add:=Subsets(toAdd,i);
     iterate:=[[*s,a*] : s in subtract, a in add];
     if randomize then
       shuffler:=[Random(100000) : i in [1..#iterate]];
       ParallelSort(~shuffler,~iterate);
     end if;
     for mons in iterate do
      ss:=&+([0] cat [getTerm(f,m) : m in mons[1]]);
      aa:=&+([0] cat [getTerm(g,m) : m in mons[2]]);
      h:=f-ss+aa;
      if isSmooth(h) then return h; end if;
     end for;
    end for;
  end for;
end function;

function BreakingPath(g1 : randomize:=false, g0:=BestFermat(g1))
  steps:=[g0];
  repeat
    h:=nextStep(steps[#steps],g1 : randomize:=randomize);
    Append(~steps,h);
  until h eq g1;
  return steps;
end function;


// X a hypersurface Z(f) in P^(n+1)
// equation: f
// dimension: n
// degree: deg X
// primitivePeriods: (primitive) period matrix of X wrt phamBasis and cohomBasis deformed via data from misc
// periods:  period matrix of X, completed from the primitive matrix by the addition of a "linear" class
// primitiveIntersectionMatrix: intersection product on primitive homology wrt to the phamBasis and cohomBasis
// intersectionMatrix: extension of primitive intersection matrix by the addition of a linear class to Fermat
// polarization: coordinates of the hyperplane class wrt the basis of homology
// hodgeLattice: (virtual) Hodge lattice, computed from the period matrix and the linear class
// precision: the precision for which the period matrix is known to be correct
// misc: intended to store the deformation family used to go to X, but also other data
PeriodBundle := recformat<equation,degree,dimension,primitivePeriods, periods,phamBasis, cohomBasis,primitiveIntersectionMatrix,intersectionMatrix,polarization,hodgeLattice,precision,odes,deformation>;


// main function
function PeriodHomotopy(path : precision:=100, straight:=false, lairez:=false, classicalPeriods:=true, randomizePath:=true, pathfinder1:=false,pathfinder2:=false) 

  beginningTime:=Cputime();

  print "\nSetting up the path, cohomology bases and transition matricies...\n";

  target:=path[#path]; 
  P:=Parent(target);
  d:=Degree(target); 
  if d eq 1 then
    error "Degree of the hypersurface needs to be greater than one.";
    return [**];
  end if;
  n:=Ngens(P)-2;

  if classicalPeriods and (Ceiling(n/2)*d-n-2 lt 0) then
    print "\nWARNING: This hypersurface has low degree and does not admit classical periods. We will now set classicalPeriods to false.\n";
    classicalPeriods := false;
  end if;

  if straight then
    if #path eq 1 then
      path:=[BestFermat(target),target];
    elif #path gt 2 then
      print "A straight path is requested with a list of more than 2 polynomials. Ignoring intermediate terms.";
      path:=[path[1],path[#path]];
    end if;
  elif #path eq 1 then 
    path:=BreakingPath(path[1] : randomize:=randomizePath); 
  end if;

  families:=[*SetupFamily(path[i],path[i+1]): i in [1..(#path-1)]*];

  if classicalPeriods then
    bases:=[*ComputeCohomologyBasis(path[i],path[i+1]): i in [1..(#path-2)]*];
    // maximum pole order for classical periods
    ll := Ceiling(n/2);
    lastForms:=[];
    for i in [1..ll] do
    polyDegree:=i*d-n-2;
      if polyDegree ge 0 then
      lastForms:=lastForms cat [mon : mon in MonomialsOfDegree(P,polyDegree)];
      end if;
    end for;
  bases:= bases cat [*lastForms*];
  else
    bases:=[*ComputeCohomologyBasis(path[i],path[i+1]): i in [1..(#path-1)]*];
  end if;

  if lairez then
    picfuchs:=lairezPicardFuchs;
  else
    picfuchs:=PicardFuchs;
  end if;

pathMons:=[#Monomials(p) : p in path];
pathMonsChange:=[#Monomials(path[j]-path[j-1]) : j in [2..#path]];

print "Using the following path:",path;
print "The number of monomials appearing at each step:\n",pathMons;
print "The number of monomials that are changed at each step:\n",pathMonsChange;

tstart:=Cputime();
  relevantDerivatives:=[];
  allODEs:=[];
  for i in [1..#families] do
    relDers:=[];
    print "\n\n************************************\nWe are at family number",i,"out of",#families,"\n************************************\n";
    if lairez then
      odes:=picfuchs(path[i],path[i+1]:forms:=bases[i], info:=Sprint(i)*"/"*Sprint(#families));
    else 
      odes:=picfuchs(families[i],bases[i]);
    end if;
    for j in [1..#odes] do
      _,requiredDerivatives := localBasis(odes[j]);
      Append(~relDers,computeDerivatives(bases[i,j],path[i],path[i+1],requiredDerivatives : withFactorial:=true));
    end for;
    Append(~relevantDerivatives,relDers);
    Append(~allODEs,odes);
  end for;

  printf "\n\nComputation of the differential equations is now complete (%o seconds). Now setting up initial conditions.\n\n", Cputime()-tstart;

  tstart:=Cputime();
  // the initial conditions for the first family
  initialPrecision:=Maximum(precision+50,Round(precision*1.2));
  initialConditions,intmat,phamB:=massIntegrate(relevantDerivatives[1],Degree(path[1]),Coefficients(path[1]) : precision:=initialPrecision); 
  // the change of coordinates necessary to setup initial conditions for later families
  coords:=[];
  for i in [2..#families] do
    coord:=coordinatesInCohomology(path[i],bases[i-1],relevantDerivatives[i]);
    Append(~coords,coord);
  end for;
  printf "\n\nInitial conditions are computed in %o seconds.\n",Cputime()-tstart;

  if pathfinder1 or pathfinder2 then
    if pathfinder2 then
      integrationPaths2d,allSings:=PathFinder2(allODEs);
    elif pathfinder1 then
      integrationPaths2d,allSings:=PathFinder1(path);
    end if;
    Cc:=ComplexField(10);
    AssignNames(~Cc,["I"]);
    integrationPaths:=[];
    for p2d in integrationPaths2d do
      integrationPath := [Sprint(pt[1] + pt[2]*Cc.1) : pt in p2d ];
      integrationPath[1]:=Sprint(0);
      integrationPath[#integrationPath]:=Sprint(1);
      Append(~integrationPaths,integrationPath);
    end for;
    singularPoints:=[planeToComplex(sings):sings in allSings];
  else
    integrationPaths:=[];
    singularPoints:=[];
  end if;

  print "\nWe are now processing the output to feed into Sage.\n";

  tstart:=Cputime();
  file:=pathToSuite*"MagmaOutput.mag";
  Write(file,"geometricGenus="*Sprint(Binomial(d-1,n+1)) : Overwrite:=true);
  Write(file,"classicalPeriods="*Sprint(classicalPeriods));
  Write(file,"paths="*Sprint(integrationPaths));
  Write(file,"allSings="*Sprint(singularPoints));
  Write(file,"rawInits="*Sprint(coords));
  Write(file,"inits="*Sprint(initialConditions));
  Write(file,"allODEs="*Sprint(allODEs));
  Write(file,"#deformationPath:="*Sprint(path));

  Write(pathToSuite*"IntersectionMatrix.mag","intmat:=Matrix("*Sprint(intmat)*")":Overwrite:=true);
  Write(pathToSuite*"IntersectionMatrix.sage","intmat=Matrix("*Sprint(intmat)*")":Overwrite:=true);
  
  file2:=pathToSuite*"Singularities.mag";
  Write(file2," ": Overwrite:=true);
  Write(file2," ");
  Write(file2,"paths="*Sprint(integrationPaths));
  Write(file2,"allSings="*Sprint(singularPoints));
  printf "Writing to external file took %o seconds.",Cputime()-tstart;
  
  tstart:=Cputime();
  System("$(which awk) -f convert.awk "*file*" > current.sage");
  System("$(which awk) -f convert.awk "*file2*" > singularities.sage");
  printf "\nConverting the output took %o seconds.\n\n", Cputime()-tstart;

  Write("current.sage","classicalPeriods="*Sprint(classicalPeriods));
  Write("current.sage","precision="*Sprint(precision));

pathMons:=[#Monomials(p) : p in path];
pathMonsChange:=[#Monomials(path[j]-path[j-1]) : j in [2..#path]];

print "Used the following path:",path;
print "The number of monomials appearing at each step:\n",pathMons;
print "The number of monomials that are changed at each step:\n",pathMonsChange;

print "\n Total time:", Cputime()-beginningTime;

print "\n\n\nBeginning integration -- calling SageMath \n\n\n";

System("$(which sage) integrator.sage");

print "Period homotopy is completed in", Cputime()-beginningTime, "seconds.";

// define a period bundle
bundle:=rec<PeriodBundle | equation:=path[#path],dimension:=n,degree:=d,primitiveIntersectionMatrix:=Matrix(intmat),phamBasis:=phamB,odes:=allODEs,deformation:=path, cohomBasis:=bases>;
  
  return bundle,[*path,bases,allODEs*];
end function;

// input: list of lists of ODEs
// order: order and degree of the ODEs
function analytics(allODEs);
  res:=[];
  for odes in allODEs do
    subres:=[];
    for ode in odes do
      code:=Coefficients(ode);
      codeN:=[Numerator(c) : c in code];
      codeD:=LCM([Denominator(c) : c in code]);
      cofs:=codeN cat [codeD];
      degs:=[Degree(c) : c in cofs];
      Append(~subres,[Degree(ode),Max(degs)]);
    end for;
    Append(~res,subres);
  end for;
  return res;
end function;

// virtual hodge lattice
// rank: rank of the (virtual) Hodge lattice
// lattice: the intersection matrix of the lattice
// basis: the basis of the lattice in terms of the basis for homology, together with a linear class
// degrees: degrees of the algebraic cycles generating the lattice
// parameters: numerical parameters used for the computation of the hodgeLattice, such as the offset and precision
virtualLattice := recformat<rank,lattice,basis,polarization,degrees,parameters>;

// input: a PeriodBundle record X
// output: X, with the intersection matrix on the entire homology of X, as well as the periods extended to entire homology
function completeHomology(X)
  // if dimension is odd, primitive homology coincides with homology
  if X`dimension mod 2 eq 1 then
    X`periods:=X`primitivePeriods;
    X`intersectionMatrix:=X`primitiveIntersectionMatrix;
    return X;
  end if;

  periods:=X`primitivePeriods;
  CC<I>:=Parent(periods[1,1]);
  d:=X`degree;
  n:=X`dimension;
  phamB:=X`phamBasis;
  IM:=ChangeRing(X`primitiveIntersectionMatrix,Rationals());
  
  // Using:
  // Degtyarev and Shimada intersection numbers
  // Theorem 2.2, arXiv:1405.4683v3
  // for explanations see: Lairez, Sertoz -- Numerical Hodge Rank

  // the helper tau function
  function tau(i)
    if i mod (2*d) eq 1 then return 1;
    elif i mod (2*d) eq 2*d-1 then return -1;
    end if;
    return 0;
  end function;

  // L is the class of a particular linear subscheme of half-dimension in Fermat.
  function intersectLwith(beta)
    return tau(2*beta[n+1]-2*beta[n+2]-1)*&*[tau(2*beta[2*i-1] - 2*beta[2*i] + 1) : i in [1..(n/2)]];
  end function;

  // We will now compute the projection of L into the primitive homology.
  intL:=Matrix([[intersectLwith(beta) : beta in phamB]]);
  IMinv:=Determinant(IM)^(-1)*Adjoint(IM);
  kappa:=ChangeRing(intL,Rationals())*IMinv;

  //self intersection of kappa
  kappaSelfIntersection:= kappa*IM*Transpose(kappa);

  // L = 1/d hyp + kappa
  // since hyp^2 = d
  // L^2 = 1/d + kappa^2 
  LSelfIntersection:=Integers()!(kappaSelfIntersection[1,1]+1/d);

  // periods of L (equivalently of kappa) are readily computed from its coordinates in the Pham basis
  Lperiods:=periods*Transpose(ChangeRing(kappa,CC));
  allPeriods:=HorizontalJoin(periods,Lperiods);
  X`periods:=allPeriods;

  // form the intersection matrix for homology by using L^2 and intL
  fullIM:=VerticalJoin(X`primitiveIntersectionMatrix,intL);
  temp:=Transpose(HorizontalJoin(intL,Matrix([[LSelfIntersection]])));
  fullIM:=HorizontalJoin(fullIM,temp);
  X`intersectionMatrix:=fullIM;

  // the hyperplane class
  // L = 1/d hyp + kappa
  // hyp = d*L - d*kappa
  X`polarization:= HorizontalJoin(ChangeRing(-d*kappa,Integers()),Matrix([[d]]));

  return X; 
end function;


// in case we computed more periods than necessary
// this function computes the number of rows that we need
function numberOfRelevantPeriods(n,d)
  P:=PolynomialRing(Rationals(),n+2);
  ll := Ceiling(n/2);
  lastForms:=[];
  for i in [1..ll] do
  polyDegree:=i*d-n-2;
    if polyDegree ge 0 then
    lastForms:=lastForms cat [mon : mon in MonomialsOfDegree(P,polyDegree)];
    end if;
  end for;
  return #lastForms;
end function;

// Input: A period bundle, we use the period matrix and the precision, but we also complete the homology

// Output: Integral linear relations between the columns of given matrix
// additional output is printed out to decide feasibility of the claimed relations
function HodgeLattice(aPeriodBundle : offset:=20)

  X:=completeHomology(aPeriodBundle);
  n:=X`dimension;
  d:=X`degree;
  v:=Matrix(X`periods[1..numberOfRelevantPeriods(n,d)]);
  CC<I>:=Parent(v[1,1]);

  precision:=X`precision-5;
  offsetPrecision:=offset;
  innerProduct:=IdentityMatrix(Integers(),NumberOfColumns(v));
  //innerProduct:=intmat;

  offsetV:=10^(precision-offsetPrecision) * v;
  Vr := [[Integers() | Round(Real(entry)) : entry in row] : row in RowSequence(offsetV)];
  Vi := [[Integers() | Round(Imaginary(entry)) : entry in row] : row in RowSequence(offsetV)];

  V:= Vr cat Vi;

  V:= Matrix(V)*innerProduct;
  VT:=10^3*Transpose(V);
  r:=NumberOfRows(VT);
  c:=NumberOfColumns(VT);
  id:=IdentityMatrix(Integers(),r);
  W:=HorizontalJoin(VT,id);
  print "Performing LLL -- this may take some time.";
  // this could be slow, but should be reliable
  time LW,B:=LLL(W:Delta:=0.9999,Eta:=0.5001,DeepInsertions:=true);
  print "Lattice reduction completed.";
  //LW,B:=LLL(W:Method:="Integral");

  // Checking relations with higher precision that was kept from LLL
  Bt:=Transpose(B);
  precisionV:=10^precision * v;
  VVr := Matrix([[Integers() | Round(Real(entry)) : entry in row] : row in RowSequence(precisionV)]);
  VVi := Matrix([[Integers() | Round(Imaginary(entry)) : entry in row] : row in RowSequence(precisionV)]);

  realError:=B*Transpose(innerProduct)*Transpose(VVr);
  imagError:=B*Transpose(innerProduct)*Transpose(VVi);

  // if these are small, relations are believable
  norms:=[ Norm(realError[i]) + Norm(imagError[i]) + Norm(B[i]): i in [1..Nrows(B)]];
  norms1:=norms; // extra copies
  norms2:=norms;

  // most promising relations go to the top
  B:=RowSequence(B);
  realError:=RowSequence(realError);
  imagError:=RowSequence(imagError);
  ParallelSort(~norms,~B);
  ParallelSort(~norms1,~realError);
  ParallelSort(~norms2,~imagError);

  // decide which relations are acceptable, if we trust our precision

  goodRelations:=[];
  for i in [1..#B] do
    // these errors should really be zero, we are allowing for rounding error, which should be close to 1
    errorIsSmall:=&and([ Abs(e) lt 100 : e in realError[i]] cat [ Abs(e) lt 100 : e in imagError[i]]);
    if errorIsSmall then
      Append(~goodRelations,B[i]);
    end if;
  end for;

  print "\nHodge rank appears to be", Sprint(#goodRelations)*".\n";
  print "Check to see if this makes sense.", "Norms of relations are listed on first row.", "Norms of the errors of these relations are listed on the second row.\n";

  B:=Matrix(B);
  realError:=Matrix(realError);
  imagError:=Matrix(imagError);
  errorField:=RealField(1);
  zeroRowLength:=#Sprint(Nrows(B));
  firstRowLength:=Maximum([#Sprint(errorField!Norm(B[j])) : j in [1..Nrows(B)]]);

  j:=1;
  num:=&*[" " : i in [1..(zeroRowLength-1)]]*"1";
  //print num,"||", "---hyperplane section---";
while (j le Nrows(B)) do
    num:=Sprint(j);
    if #num lt zeroRowLength then
      num:=&*[" " : i in [1..(zeroRowLength-#num)]]*num;
    end if;
    rowOne:=Sprint(errorField!Norm(B[j]));
    whiteSpace:=&*[" " : i in [0..(firstRowLength-#rowOne)]];
    print num, "||", rowOne*whiteSpace, "   ", errorField!(Norm(realError[j])+Norm(imagError[j]));
    j:=j+1;
end while;
  print "\n";

// Forming the Hodge lattice

rho:=#goodRelations;
IM:=X`intersectionMatrix;
hyp:=X`polarization;
degrees:=[B[i]*IM*Transpose(hyp) : i in [1..rho]]; 

basis:=RowSequence(B)[1..rho];
lattice:=Matrix(basis)*IM*Transpose(Matrix(basis));

//polarization, in the coordinates of the lattice
Lambda:=LatticeWithBasis(Matrix(basis));
hyp:=hyp[1]; // one-row-matrix is converted to a vector
polarization:=Coordinates(Lambda!hyp);

hdgLattice := rec<virtualLattice | rank:=rho, lattice:=lattice, basis:=basis, degrees:=degrees, parameters:=[precision,offsetPrecision], polarization:=polarization>;

  X`hodgeLattice:=hdgLattice;

  return X,rho,lattice;
end function;
